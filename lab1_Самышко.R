# версия R:
 # R.version
 # _                           
 # platform       x86_64-w64-mingw32          
 # arch           x86_64                      
 # os             mingw32                     
 # system         x86_64, mingw32             
 # status                                     
 # major          4                           
 # minor          0.2                         
 # year           2020                        
 # month          06                          
 # day            22                          
 # svn rev        78730                       
 # language       R                           
 # version.string R version 4.0.2 (2020-06-22)
 # nickname       Taking Off Again  


# Загрузка библиотек
library('Hmisc')          # для расчёта корреляционной матрицы
library('corrplot')       # визуализация корреляционных матриц: corrplot()
library('nortest')        # для теста Андерсона-Дарлинга ad.test()

# установка рабочей директории
setwd("E:/Program files/Rstudio codes")
?title
# 1. Импорт данных  ------------------------------------------------------------

# проверка содержимого рабочей директории
dir()

# импорт данных из .csv
#file.path <- 'https://raw.githubusercontent.com/Polina-MbILIJb/R-language/master/Данные_Самышко.csv'
file.path <- 'Данные_Самышко.csv'
DF <- read.csv2(file.path, stringsAsFactors = F) #фрейм с обычными данным
DF

# размерность фрейма
dim(DF)

# структура фрейма
str(DF)    

# делаем из столбца "FO" фактор
DF$FO <- factor(DF$FO)

# оставляем только регионы и выбрасываем столбец меток, 
#  чтобы удобнее было считать
reg.df <- DF[DF$Reg.code < 1000, c(-1, -2)]
# выбрасываем пропущенные
reg.df <- na.omit(reg.df)

# первые пять строк фрейма
head(reg.df)
# последние пять строк фрейма
tail(reg.df)

#фрейм с логарифмированными данными
DF1 <- reg.df
DF1$Y.ORTorg.2013 <- log(reg.df$Y.ORTorg.2013)
DF1$KMPred.2013 <- log(reg.df$KMPred.2013)
DF1$Pers.comp.2013 <- log(reg.df$Pers.comp.2013)
DF1$RKBS.2012 <- log(reg.df$RKBS.2012)
DF1$RDDN.2013 <- log(reg.df$RDDN.2013)

# 2. Описательные статистики  --------------------------------------------------

# встроенная функция расчёта описательных статистик
summary(reg.df)
summary(DF1)

# ручной расчёт
#  средние арифметические
mns <- round(apply(reg.df[, -1], 2, mean), 1)
mns1 <- round(apply(DF1[, -1], 2, mean), 3)
mns

#  стандартные отклонения
sds <- round(apply(reg.df[, -1], 2, sd), 1)
sds1 <- round(apply(DF1[, -1], 2, sd), 3)
sds

#  коэффициенты вариации
coef.vars <- round(sds / mns * 100, 1)
coef.vars1 <- round(sds1 / mns1 * 100, 3)
coef.vars

# делаем свою таблицу только с нужными статистиками 
#  по количественным показателям: среднее, СКО, коэффициент вариации
smm <- rbind(mns, sds, coef.vars)
smm1 <- rbind(mns1, sds1, coef.vars1)
# названия статистик -- заголовки строк
row.names(smm) <- c('Среднее', 'Стандартное отклонение',
                    'Коэффициент вариации, %')
row.names(smm1) <- c('Среднее', 'Стандартное отклонение',
                    'Коэффициент вариации, %')
#Таблица: среднее, СКО, коэф.вар. для изначальных значений
smm
#Таблица: среднее, СКО, коэф.вар. для логарифмированных значений
smm1



# 3. Анализ распределения данных  ----------------------------------------------


# Гистограммы ==================================================================

# строим гистограммы на одном полотне по изначальным данным
par(mfrow = c(2, 3))           # разбить полотно на 6 частей, 2x3
par(oma = c(0, 0, 1.5, 0))     # внешние поля общего полотна
par(mar = c(4, 4, 0.5, 0.5))   # внутренние поля каждого графика

# цикл по номерам столбцов с количественными переменными
for (i in 2:6) {
  # данные -- i-ый столбец фрейма
  x <- reg.df[, i]
  
  # гистограмма
  hist(x,
       freq = F,            # по вертикали – плотность (доля)
       col = 'wheat',       # цвет заливки
       xlab = colnames(reg.df)[i],     # название оси X – название столбца 
       ylab = 'Плотность',             # название оси Y
       main = '')                      # без заголовка
  
  #фактическая плотность
  lines(density(x),col = "red", lwd = 2)
  
  # теоретическая плотность
  curve(dnorm(x, mean = mean(x), sd = sd(x)), col = 'darkblue', 
        lwd = 2, add = TRUE)

}

# общий заголовок для всех графиков
title(main = 'Гистограммы распределения показателей', 
      outer = TRUE, cex = 1.5)

# вернуть настройки обратно, 1x1
par(mfrow = c(1, 1))


# строим гистограммы на одном полотне по логарифмированным данным
par(mfrow = c(2, 3))           # разбить полотно на 6 частей, 2x3
par(oma = c(0, 0, 1.5, 0))     # внешние поля общего полотна
par(mar = c(4, 4, 0.5, 0.5))   # внутренние поля каждого графика

# цикл по номерам столбцов с количественными переменными
for (i in 2:6) {
  # данные -- i-ый столбец фрейма
  x <- DF1[, i]
  
  # гистограмма
  hist(x,
       freq = F,            # по вертикали – плотность (доля)
       col = 'wheat',       # цвет заливки
       xlab = colnames(reg.df)[i],     # название оси X – название столбца 
       ylab = 'Плотность',             # название оси Y
       main = '')                      # без заголовка
  
  #фактическая плотность
  lines(density(x),col = "red", lwd = 2)
  
  # теоретическая плотность
  curve(dnorm(x, mean = mean(x), sd = sd(x)), col = 'darkblue', 
        lwd = 2, add = TRUE)
  
}

# общий заголовок для всех графиков
title(main = 'Гистограммы распределения логарифмированных показателей', 
      outer = TRUE, cex = 1.5)

# вернуть настройки обратно, 1x1
par(mfrow = c(1, 1))



# Тесты на нормальность ========================================================

# тест Шапиро-Уилка на нормальность распределения
# применяем ко всем столбцам с помощью apply()
lapply(reg.df[, 2:6], shapiro.test)

# структура объекта
#str(shapiro.test(reg.df$Y.ORTorg.2013))

# применяем ко всем столбцам и вытаскиваем только тестовую статистику
# для изначальных значений
table <- c(sapply(reg.df[, 2:6], function(x) {
  round(shapiro.test(x)$statistic, 4)
}),sapply(reg.df[, 2:6], function(x) {
  round(shapiro.test(x)$p.value, 4)
}))

# для логарифмированных значений
table1 <- c(sapply(DF1[, 2:6], function(x) {
  round(shapiro.test(x)$statistic, 4)
}),sapply(DF1[, 2:6], function(x) {
  round(shapiro.test(x)$p.value, 4)
}))

# тест Шапиро-Уилка на нормальность распределения для изначальных значений
table
# тест Шапиро-Уилка на нормальность распределения для логарифмированных значений
table1

# Тест Андерсона-Дарлинга на нормальность распределения
#lapply(reg.df[,2:6], ad.test)


# 4. Анализ линейных взаимосвязей  ---------------------------------------------


# Графики разброса =============================================================

# графики взаимного разброса по изначальным данным
pairs(reg.df[, -1],     # фрейм без первого столбца-фактора
      pch = 2,         # тип символов для точек
      col = rgb(1, 0, 0, alpha = 0.4),   # цвет заливки точек
      bg = rgb(0, 0, 1, alpha = 0.4),    # цвет границы точек
      cex = 1.1)                 # масштаб символов для точек

# графики взаимного разброса по логарифмированным данным
pairs(DF1[, -1],     # фрейм без первого столбца-фактора
      pch = 5,         # тип символов для точек
      col = rgb(0, 0, 1, alpha = 0.4),   # цвет заливки точек
      bg = rgb(0, 0, 1, alpha = 0.4),    # цвет границы точек
      cex = 1.1)                 # масштаб символов для точек

# Корреляционная матрица  ======================================================

# коэффициенты Пирсона с P-значениями
r.corr <- rcorr(as.matrix(reg.df[, -1]))
r.corr

# Визуализация корреляционной матрицы  =========================================

# сохраняем корреляционную матрицу
matrix.cor <- r.corr$r

# сохраняем p-значения
matrix.p <- r.corr$P

# изображаем матрицу графически
corrplot(matrix.cor,          # сама корреляционная матрица
         order = 'original',  # порядок отображения показателей 
         # в матрице
         diag = F,            # не отображать значения на главной 
         # диагонали
         p.mat = matrix.p,    # p-значения
         #insig = 'blank',     # метод отображения незначимых
         sig.level = 0.05)    # уровень значимости
title(main = 'Корреляция показателей', 
      outer = TRUE, cex = 1.5)



# коэффициенты Пирсона с P-значениями
r.corr <- rcorr(as.matrix(DF1[, -1]))

# Визуализация корреляционной матрицы  =========================================

# сохраняем корреляционную матрицу
matrix.cor <- r.corr$r

# сохраняем p-значения
matrix.p <- r.corr$P

# изображаем матрицу графически
corrplot(matrix.cor,          # сама корреляционная матрица
         order = 'original',  # порядок отображения показателей 
         # в матрице
         diag = F,            # не отображать значения на главной 
         # диагонали
         p.mat = matrix.p,    # p-значения
         #insig = 'blank',     # метод отображения незначимых
         sig.level = 0.05)    # уровень значимости
title(main = 'Корреляция логарифмированных показателей', 
      outer = TRUE, cex = 1.5)



# 5. Сохранение рабочего пространства  ------------------------------------------

# список объектов в памяти
ls()

# сохраняем нужные объекты в файл
save(list = c('DF', 'reg.df', 'DF1'), file = 'test_lab1_Самышко.RData')
save.image()
rm()

